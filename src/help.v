module flip

import strings
import math
import term

// show_help prints the help generated by `generate_help`
pub fn (f Flip) show_help() {
	print(f.generate_help(7, true))
}

pub fn (f Flip) show_help_without_flags() {
	print(f.generate_help(7, false))
}

fn (f []&Flip) help_spec() int {
	mut max_length := 0
	for cmd in f {
		if cmd.name.len > max_length {
			max_length = cmd.name.len
		}
	}
	return max_length
}

fn (f []&Flag) help_spec() (int, bool) {
	mut any_shorts := false
	mut max_length := 0
	for flag in f {
		short_len := flag.printed_shorthand_len()
		length := short_len + 1 + flag.name.len
		if short_len > 0 {
			any_shorts = true
		}
		if length > max_length {
			max_length = length
		}
	}
	return max_length, any_shorts
}

// generate_help generates help for the command
pub fn (f Flip) generate_help(min_pad int, with_flags bool) string {
	mut total_max_length, any_short_flags := f.root().flag_parser.flags.help_spec()
	total_max_length = math.max(f.commands.help_spec(), total_max_length)
	mut sb := strings.new_builder(f.name.len + f.description.len)
	if f.description.len > 0 {
		sb.write_string('${f.description}\n\n')
	}
	if custom_usage := f.custom_usage {
		sb.write_string(custom_usage)
	} else {
		sb.write_string('Usage: ${f.name}')
		if f.takes_flags {
			sb.write_string(' [options]')
		}
		if f.commands.len > 0 {
			sb.write_string(' [command]')
		}
		if f.ignore_unknown_cmds {
			sb.write_string(' [arguments]')
		}
		sb.write_rune(`\n`)
	}
	mut categorized := map[string][]Flip{}
	categories := f.root().categories
	unsafe {
		for cmd in f.commands {
			if cmd.category !in categories {
				if cmd.category.len > 0 {
					f.root().get_category(cmd.category)
				}
				categorized[''] << *cmd
				continue
			}
			categorized[f.root().get_category(cmd.category)] << *cmd
		}
		if categorized[''].len > 0 {
			sb.write_string(categorized[''].generate_string(min_pad, total_max_length,
				any_short_flags))
		}
	}
	if f.commands.len - categorized.len <= 0 {
		sb.write_rune(`\n`)
	}
	for title, cmds in categorized {
		if title.len <= 0 {
			continue
		}
		sb.writeln('* ${title}\n' + cmds.generate_string(min_pad, total_max_length, any_short_flags))
	}
	if with_flags {
		flags := f.root().flag_parser.flags.generate_string(min_pad, total_max_length,
			any_short_flags, f)
		if flags.len > 0 {
			sb.writeln('* Flags:\n' + flags)
		}
	}
	return sb.str()
}

fn (f []Flip) generate_string(min_pad int, max_length int, any_shorts bool) string {
	mut sb := strings.new_builder(max_length * f.len)
	for cmd in f {
		padding := min_pad + (max_length - cmd.name.len)
		padded := '  ' + cmd.name + ' '.repeat(padding) + ' ' +
			wrap_description(cmd.description, 2 + cmd.name.len + padding + 1)
		if any_shorts {
			sb.write_string('${' ':3}')
		}
		sb.writeln(padded)
	}
	return sb.str()
}

fn (f []&Flag) generate_string(min_pad int, max_length int, any_shorts bool, flip_ Flip) string {
	mut sb := strings.new_builder(max_length * f.len)
	for flag in f {
		label := '  ' + if flag.shorthand != ` ` {
			'${flag.shorthand}, '
		} else {
			''
		} + '${flag.name}'
		padding := min_pad + (max_length - flag.name.len)
		first_padding := if flag.printed_shorthand_len() <= 0 && any_shorts {
			' '.repeat(3)
		} else {
			''
		}
		padded := first_padding + label + ' '.repeat(padding) + ' ' +
			wrap_description(flag.description, first_padding.len + label.len + padding + 1)
		sb.writeln(padded)
	}
	return sb.str()
}

fn (f Flag) printed_shorthand_len() int {
	return if f.shorthand != ` ` { 3 } else { 0 }
}

fn wrap_description(s string, pad int) string {
	w, _ := term.get_terminal_size()
	rep := s.replace('\n', '\n' + ' '.repeat(pad))
	if rep.len + pad > w {
		return rep[..w - pad] + '\n' + ' '.repeat(pad) + wrap_description(rep[w - pad..], pad)
	}
	return rep
}
