module flip

import strings
import math

// show_help prints the help generated by `generate_help`
pub fn (f Flip) show_help() {
	print(f.generate_help(7))
}

fn (f []&Flip) help_spec() int {
	mut max_length := 0
	for cmd in f {
		if cmd.name.len > max_length {
			max_length = cmd.name.len
		}
	}
	return max_length
}

fn (f []&Flag) help_spec() (int, bool) {
	mut any_shorts := false
	mut max_length := 0
	for flag in f {
		short_len := flag.printed_shorthand_len()
		length := short_len + 1 + flag.name.len
		if short_len > 0 {
			any_shorts = true
		}
		if length > max_length {
			max_length = length
		}
	}
	return max_length, any_shorts
}

// generate_help generates help for the command
pub fn (f Flip) generate_help(min_pad int) string {
	mut total_max_length, any_short_flags := f.root().flag_parser.flags.help_spec()
	total_max_length = math.max(f.commands.help_spec(), total_max_length)
	mut sb := strings.new_builder(f.name.len + f.description.len)
	if f.description.len > 0 {
		sb.write_string('${f.description}\n\n')
	}
	if custom_usage := f.custom_usage {
		sb.write_string(custom_usage)
	} else {
		sb.write_string('Usage: ${f.name}')
		if f.takes_flags {
			sb.write_string(' [options]')
		}
		if f.commands.len > 0 {
			sb.write_string(' [command]')
		}
		if f.no_unknown_cmds {
			sb.write_string(' [arguments]')
		}
		sb.write_rune(`\n`)
	}
	mut categorized := map[string][]Flip{}
	categories := f.root().categories
	mut uncategorized_count := 0
	unsafe {
		for cmd in f.commands {
			if cmd.category !in categories {
				if cmd.category.len > 0 {
					f.root().get_category(cmd.category)
				}
				uncategorized_count++
				categorized[''] << *cmd
				continue
			}
			categorized[f.root().get_category(cmd.category)] << *cmd
		}
		if categorized[''].len > 0 {
			sb.write_string(categorized[''].generate_string(min_pad, total_max_length,
				any_short_flags))
		}
	}
	if uncategorized_count >= 0 {
		sb.write_rune(`\n`)
	}
	for title, cmds in categorized {
		if title.len <= 0 {
			continue
		}
		sb.writeln('* ${title}\n' + cmds.generate_string(min_pad, total_max_length, any_short_flags))
	}
	flags := f.root().flag_parser.flags.generate_string(min_pad, total_max_length, any_short_flags,
		f)
	if flags.len > 0 {
		sb.writeln('* Flags:\n' + flags)
	}
	return sb.str()
}

fn (f []Flip) generate_string(min_pad int, max_length int, any_shorts bool) string {
	mut sb := strings.new_builder(max_length * f.len)
	for cmd in f {
		padding := min_pad + (max_length - cmd.name.len)
		padded := '  ' + cmd.name + ' '.repeat(padding) + ' ' + cmd.description
		if any_shorts {
			sb.write_string('${' ':3}')
		}
		sb.writeln(padded)
	}
	return sb.str()
}

fn (f []&Flag) generate_string(min_pad int, max_length int, any_shorts bool, flip_ Flip) string {
	mut sb := strings.new_builder(max_length * f.len)
	for flag in f {
		label := '  ' + if flag.shorthand != ` ` {
			'${flag.shorthand}, '
		} else {
			''
		} + '${flag.name}'
		padding := min_pad + (max_length - flag.name.len)
		first_padding := if flag.printed_shorthand_len() <= 0 && any_shorts {
			' '.repeat(3)
		} else {
			''
		}
		padded := first_padding + label + ' '.repeat(padding) + ' ' + flag.description
		sb.writeln(padded)
	}
	return sb.str()
}

fn (f Flag) printed_shorthand_len() int {
	return if f.shorthand != ` ` { 3 } else { 0 }
}
